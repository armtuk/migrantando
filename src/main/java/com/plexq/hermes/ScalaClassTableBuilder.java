/*
        Copyright Alex R.M. Turner 2008
        This file is part of Hermes DB
        Hermes DB is free software; you can redistribute it and/or modify
        it under the terms of the Lesser GNU General Public License as published by
        the Free Software Foundation; version 3 of the License.

        Hermes DB is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the Lesser GNU General Public License
        along with Hermes DB if not, write to the Free Software
        Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
        This file is released under the LGPL v3.0
*/
package com.plexq.hermes;

import java.io.*;
import java.sql.SQLException;
import java.util.*;

// TODO make this smart enough to figure out inheritance chain somehow, at least for our case, cope with mapping entity if appropriate
public class ScalaClassTableBuilder extends TableBuilder {
    private String packageName;

    private String dumpPath;

    private List<String> entityFields;

    public ScalaClassTableBuilder() {
        entityFields = new ArrayList<String>();
        entityFields.addAll(Arrays.asList(entityFieldsS));
    }

    private static String[] entityFieldsS = {
            "id",
            "created_timestamp",
            "updated_timestamp",
            "version",
            "Version",
            "updated_by_id",
            "created_by_id"
    };

    @Override
    public String buildTable(TableRepresentation tr) throws SQLException, TableBuildException {
        File f = new File(dumpPath + "/" + convertToCamelCaseFormat(tr.getTableName(),true) + ".scala");
        tr.setTypeNameFactory(new ScalaTypeNameFactory());
        try {
            FileWriter fw = new FileWriter(f);
            System.out.println("Writing to " + f.getPath());

            StringBuilder sql=new StringBuilder();

            sql.append("package ");
            sql.append(packageName);
            sql.append("\n\n");

            sql.append("\n" +
                    "import play.api.db._\n" +
                    "import play.api.Play.current\n" +
                    "\n" +
                    "import anorm._\n" +
                    "import anorm.SqlParser._\n" +
                    "import models.util.DBHelper\n");
            sql.append("\n");

            sql.append("/**\n * Autogenerated by ScalaClassTableBuilder\n */\n");

            sql.append(generateCaseClass(tr));
            sql.append(generateObject(tr));

            fw.write(sql.toString());
            fw.close();

            return sql.toString();
        }
        catch (IOException ioe) {
            throw new RuntimeException("FAILED", ioe);
        }
    }

        public String generateCaseClass(TableRepresentation tr) throws TableBuildException {
            StringBuilder sql = new StringBuilder();
            sql.append("case class ");
            sql.append(convertToCamelCaseFormat(tr.getTableName(), true));
            sql.append("(");

            for (String a: tr.getTableTypes().keySet()) {
                sql.append(convertToCamelCaseFormat(a, false));
                sql.append(": ");
                sql.append(tr.getTypeName(a));
                sql.append(", ");
            }
            sql = trimRight(sql, 2);
            sql.append(")\n\n");
            return sql.toString();
        }


        public String generateObject(TableRepresentation tr) throws TableBuildException {
            TreeMap<String, Class> types = tr.getTableTypes();

            StringBuilder sql = new StringBuilder();
            sql.append("object ");
            sql.append(convertToCamelCaseFormat(tr.getTableName(), true));
            sql.append(" {\n");

            sql.append("\tval simple = {\n");

            for (String a: types.keySet()) {
                sql.append("\t\tget[");
                sql.append(tr.getTypeName(a));
                sql.append("](\"");
                sql.append(a);
                sql.append("\") ~\n");
            }

            sql = trimRight(sql, 2);
            sql.append(" map {\n\t\t\tcase ");

            for (String a: types.keySet()) {
                sql.append(convertToCamelCaseFormat(a, false));
                sql.append(" ~ ");
            }

            sql = trimRight(sql, 2);

            sql.append("=> {\n\t\t\t\t");
            sql.append(convertToCamelCaseFormat(tr.getTableName(), true));
            sql.append("(");

            for (String a: types.keySet()) {
                sql.append(convertToCamelCaseFormat(a, false));
                sql.append(", ");
            }


            sql = trimRight(sql, 2);

            sql.append(")\n");

            // End Case
            sql.append("\t\t\t}\n");
            // End Map
            sql.append("\t\t}\n");
            // End val
            sql.append("\t}\n\n");

            sql.append(buildFindByIdFunction(tr));
            sql.append(buildPersistFunction(tr));
            sql.append(buildUpdateFunction(tr));

            sql.append("}");

            return sql.toString();
        }

        public String buildPersistFunction(TableRepresentation tr) throws TableBuildException {
            TreeMap<String, Class> types = tr.getTableTypes();

            StringBuilder sql = new StringBuilder();
            // Persist the Class to the database
            sql.append("\tdef persist(obj: ");
            sql.append(convertToCamelCaseFormat(tr.getTableName(),true));
            sql.append(") = {\n");
            sql.append("\t\tDB.withTransaction { implicit connection =>\n");

            if (tr.getPrimaryKeys().length == 1 && Arrays.asList(new String[]{"Long","Integer"}).contains(tr.getTypeName(tr.getPrimaryKeys()[0]))) {
                sql.append("\t\t\tvar c = obj.copy(");
                sql.append(tr.getPrimaryKeys()[0]);
                if (tr.getTypeName(tr.getPrimaryKeys()[0]).equals("Int")) {
                    sql.append("=DBHelper.nextId.toInt)\n\n");
                }
                else {
                    sql.append("=DBHelper.nextId)\n\n");
                }
            }
            else {
                sql.append("\t\t\tvar c = obj\n\n");
            }

            sql.append("\t\t\tSQL(\"insert into ");
            sql.append(tr.getTableName());
            sql.append(" values (");

            for (String a: types.keySet()) {
                sql.append(a);
                sql.append(", ");
            }

            sql = trimRight(sql, 2);

            sql.append(")\" + \n\t\t\t\t\" values (");

            for (String a: types.keySet()) {
                sql.append("{");
                sql.append(convertToCamelCaseFormat(a,false));
                sql.append("}, ");
            }
            sql = trimRight(sql, 2);

            sql.append(")\")\n");
            sql.append("\t\t\t.on(");


            for (String a: types.keySet()) {
                sql.append("'");
                sql.append(convertToCamelCaseFormat(a,false));
                sql.append(" -> c.");
                sql.append(convertToCamelCaseFormat(a, false));
                sql.append(", ");
            }

            sql = trimRight(sql, 2);

            sql.append(").executeInsert()\n");
            // End DB.withTransaction
            sql.append("\t\t}\n");
            // End def
            sql.append("\t}\n\n");

            return sql.toString();
        }

    public String buildFindByIdFunction(TableRepresentation tr) throws TableBuildException {
        StringBuilder sql = new StringBuilder();

        sql.append("\tdef findById(id: ");
        sql.append(tr.getTypeName(tr.getPrimaryKeys()[0]));
        sql.append(") = {\n\t\tDB.withConnection { implicit connection =>\n");
        sql.append("\t\t\tSQL(\"select * from ");
        sql.append(tr.getTableName());
        sql.append(" where ");
        sql.append(tr.getPrimaryKeys()[0]);
        sql.append(" = {id}\")\n\t\t\t\t.on('id -> id).as(");
        sql.append(convertToCamelCaseFormat(tr.getTableName(), true));
        sql.append(".simple.singleOpt)\n");
        // End Db Connection
        sql.append("\n\t\t}\n");
        // End def
        sql.append("\n\t}\n");

        return sql.toString();
    }

    public String buildUpdateFunction(TableRepresentation tr) {
        TreeMap<String, Class> types = tr.getTableTypes();
        StringBuilder sql = new StringBuilder();

            sql.append("\tdef update(c: ");
            sql.append(convertToCamelCaseFormat(tr.getTableName(), true));
            sql.append(") = {\n");
            sql.append("\t\tDB.withTransaction { implicit connection =>\n");
            sql.append("\t\t\tSQL(\"update ");
            sql.append(tr.getTableName());
            sql.append(" set ");

            for (String a : types.keySet()) {
                if (!Arrays.asList(tr.getPrimaryKeys()).contains(a)) {
                    sql.append(a);
                    sql.append(" = {");
                    sql.append(convertToCamelCaseFormat(a, false));
                    sql.append("}, ");
                }
            }

            sql = trimRight(sql, 2);

            sql.append(" where ");

            for (String a: tr.getPrimaryKeys()) {
                sql.append(a);
                sql.append(" = {");
                sql.append(convertToCamelCaseFormat(a, false));
                sql.append("} and ");
            }

            sql = trimRight(sql, 5);

            sql.append("\")\n");
            sql.append("\t\t\t.on(");

            for (String a: types.keySet()) {
                sql.append("'");
                sql.append(convertToCamelCaseFormat(a, false));
                sql.append(" -> c.");
                sql.append(convertToCamelCaseFormat(a, false));
                sql.append(", ");
            }

            sql = trimRight(sql, 2);
            sql.append(").executeUpdate()\n");
            //End DB with Transaction
            sql.append("\t\t}\n");
            // End def
            sql.append("\t}\n");

        return sql.toString();
    }

    public void setPackageName(String packageName) {
        this.packageName = packageName;
    }

    public String getDumpPath() {
        return dumpPath;
    }

    public void setDumpPath(String dumpPath) {
        this.dumpPath = dumpPath;
    }

    public List<String> getEntityFields() {
        return entityFields;
    }

    public void setEntityFields(List<String> entityFields) {
        this.entityFields = entityFields;
    }

    public StringBuilder trimRight(StringBuilder s, Integer count) {
        return new StringBuilder(s.substring(0,s.length()-count));
    }
}
